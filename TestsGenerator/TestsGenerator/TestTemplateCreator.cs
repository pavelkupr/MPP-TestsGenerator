using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGenerator
{
	internal class TestTemplateCreator
	{
		public List<CreatedTestTemplate> GenerateFileAsync(string source)
		{
			List<CreatedTestTemplate> result = new List<CreatedTestTemplate>();

			SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source);
			CompilationUnitSyntax compilationUnitSyntax = syntaxTree.GetCompilationUnitRoot();

			foreach (ClassDeclarationSyntax classInfo in compilationUnitSyntax.DescendantNodes().OfType<ClassDeclarationSyntax>())
			{
				string namespaceName = (classInfo.Parent as NamespaceDeclarationSyntax)?.Name.ToString();
				string className = classInfo.Identifier.ValueText;
				List<string> testMethodsName = new List<string>();
				List<MethodDeclarationSyntax> publicMethods = new List<MethodDeclarationSyntax>();
				foreach( var method in classInfo.DescendantNodes().OfType<MethodDeclarationSyntax>())
				{
					if (method.Modifiers.Any(x => x.ValueText == "public"))
					{
						publicMethods.Add(method);
					}
				}

				foreach (var method in publicMethods)
				{
					var name = GetMethodName(testMethodsName, method.Identifier.ToString(), 0);
					testMethodsName.Add(name);
				}

				NamespaceDeclarationSyntax namespaceDeclarationSyntax = NamespaceDeclaration(QualifiedName(
					IdentifierName(namespaceName), IdentifierName("Test")));

				CompilationUnitSyntax compilationUnit = CompilationUnit()
					.WithUsings(GetUsings())
					.WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDeclarationSyntax
						.WithMembers(SingletonList<MemberDeclarationSyntax>(ClassDeclaration(className + "Test")
							.WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestClass"))))))
							.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
							.WithMembers(GetMethods(testMethodsName))))));


				
				CreatedTestTemplate resultElement = new CreatedTestTemplate();
				resultElement.Text = compilationUnit.NormalizeWhitespace().ToFullString();
				resultElement.Name = $"{className}Tests.cs";
				result.Add(resultElement);
			}

			return result;
		}

		private SyntaxList<UsingDirectiveSyntax> GetUsings()
		{
			List<UsingDirectiveSyntax> usingDirective = new List<UsingDirectiveSyntax>()
			{
				UsingDirective(
					QualifiedName(
						QualifiedName(
							QualifiedName(
								IdentifierName("Microsoft"),
								IdentifierName("VisualStudio")),
							IdentifierName("TestTools")),
						IdentifierName("UnitTesting")))
			};

			return List(usingDirective);
		}

		private SyntaxList<MemberDeclarationSyntax> GetMethods(List<string> methods)
		{
			var result = new List<MemberDeclarationSyntax>();
			foreach (var method in methods) result.Add(GetMethod(method));

			return List(result);
		}

		private MethodDeclarationSyntax GetMethod(string name)
		{
			return MethodDeclaration(
					PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier(name + "Test"))
				.WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(
								Attribute(IdentifierName("TestMethod"))))))
				.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
				.WithBody(Block(ExpressionStatement(InvocationExpression(
					MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
						IdentifierName("Assert"), IdentifierName("Fail")))
							.WithArgumentList(ArgumentList(SingletonSeparatedList(
								Argument(LiteralExpression(SyntaxKind.StringLiteralExpression,
									Literal("autogenerated")))))))));
		}

		private string GetMethodName(List<string> methods, string method, int count)
		{
			var result = method + (count == 0 ? "" : count.ToString());

			if (methods.Contains(result))
				return GetMethodName(methods, method, count + 1);

			return result;
		}
	}
}
