using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
namespace TestsGenerator
{
	class TestClassCreator
	{
		public List<GeneratedResult> GenerateFileAsync(string source)
		{
			var res = new List<GeneratedResult>();
			
			var syntaxTree = CSharpSyntaxTree.ParseText(source);
			var compilationUnitSyntax = syntaxTree.GetCompilationUnitRoot();

			var classes = compilationUnitSyntax.DescendantNodes().OfType<ClassDeclarationSyntax>();

			foreach (var classDeclaration in classes)
			{
				var publicMethods = classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>()
					.Where(x => x.Modifiers.Any(y => y.ValueText == "public"));

				var ns = (classDeclaration.Parent as NamespaceDeclarationSyntax)?.Name.ToString();
				var className = classDeclaration.Identifier.ValueText;
				var methodsName = new List<string>();
				foreach (var method in publicMethods)
				{
					var name = GetMethodName(methodsName, method.Identifier.ToString(), 0);
					methodsName.Add(name);
				}

				NamespaceDeclarationSyntax namespaceDeclarationSyntax = NamespaceDeclaration(QualifiedName(
					IdentifierName(ns), IdentifierName("Test")));

				CompilationUnitSyntax compilationUnit = CompilationUnit()
					.WithUsings(GetUsings())
					.WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDeclarationSyntax
						.WithMembers(SingletonList<MemberDeclarationSyntax>(ClassDeclaration(className + "Test")
							.WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestClass"))))))
							.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
							.WithMembers(GetMethods(methodsName))))));



				var outputPath = $"{className}Tests.cs";
				res.Add(new GeneratedResult
				{
					Text = compilationUnit.NormalizeWhitespace().ToFullString(),
					Name = outputPath
				});
			}

			return res;
		}

		private SyntaxList<UsingDirectiveSyntax> GetUsings()
		{
			List<UsingDirectiveSyntax> usingDirective = new List<UsingDirectiveSyntax>()
			{
				UsingDirective(
					QualifiedName(
						QualifiedName(
							QualifiedName(
								IdentifierName("Microsoft"),
								IdentifierName("VisualStudio")),
							IdentifierName("TestTools")),
						IdentifierName("UnitTesting")))
			};

			return List(usingDirective);
		}

		private SyntaxList<MemberDeclarationSyntax> GetMethods(List<string> methods)
		{
			var result = new List<MemberDeclarationSyntax>();
			foreach (var method in methods) result.Add(GetMethod(method));

			return List(result);
		}

		private MethodDeclarationSyntax GetMethod(string name)
		{
			return MethodDeclaration(
					PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier(name + "Test"))
				.WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(
								Attribute(IdentifierName("TestMethod"))))))
				.WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
				.WithBody(Block(ExpressionStatement(InvocationExpression(
					MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
						IdentifierName("Assert"), IdentifierName("Fail")))
							.WithArgumentList(ArgumentList(SingletonSeparatedList(
								Argument(LiteralExpression(SyntaxKind.StringLiteralExpression,
									Literal("autogenerated")))))))));
		}

		private string GetMethodName(List<string> methods, string method, int count)
		{
			var res = method + (count == 0 ? "" : count.ToString());
			if (methods.Contains(res)) return GetMethodName(methods, method, count + 1);

			return res;
		}
	}

	internal class GeneratedResult
	{
		public string Text { get; set; }
		public string Name { get; set; }
	}
}
